// Drag & Drop Interfaces
// These interfaces define the methods required for drag-and-drop functionality.
// Draggable interface is for elements that can be dragged,
// while DragTarget interface is for elements that can accept dropped items.
// They ensure that classes implementing these interfaces provide the necessary methods for handling drag events.
interface Draggable {
  dragStartHandler(event: DragEvent): void;
  dragEndHandler(event: DragEvent): void;
}

interface DragTarget {
  dragOverHandler(event: DragEvent): void;
  dropHandler(event: DragEvent): void;
  dragLeaveHandler(event: DragEvent): void;
}

// Project Type
// This enum defines the possible statuses of a project.
// It can be either Active or Finished, which helps in managing the state of projects.
enum ProjectStatus {
  Active,
  Finished
}
// Project Class
// This class represents a project with its properties such as id, title, description, number of people involved, and its status.
// It serves as a model for the projects managed in the application.    
class Project {
  constructor(
    public id: string,
    public title: string,
    public description: string,
    public people: number,
    public status: ProjectStatus
  ) { }
}

// Project State Management

// The Listener type is a function that takes an array of projects and is called when the state changes.
type Listener<T> = (items: T[]) => void;

// The State class is a generic class that manages listeners for any type T, allowing for flexible state management.
// It provides an addListener method to register listeners that will be notified when the state changes.
class State<T> {
  protected listeners: Listener<T>[] = [];

  addListener(listenerFn: Listener<T>) {
    this.listeners.push(listenerFn);
  }
}

// This class manages the state of projects in the application.
// It extends a generic State class that handles listeners for state changes.
// The ProjectState class is a singleton, ensuring only one instance exists throughout the application.
// It provides methods to add projects, move projects between statuses, and notify listeners of changes.
class ProjectState extends State<Project> {
  // projects is an array that holds the current projects.
  // It is initialized as an empty array and will be populated with Project instances.
  // The static instance property ensures that only one instance of ProjectState exists (singleton pattern).
  // The constructor is private to prevent direct instantiation from outside the class.
  // The getInstance method checks if an instance already exists; if not, it creates a new one.
  private projects: Project[] = [];
  // The static instance property holds the single instance of ProjectState.
  // It is initialized as undefined and will be set when getInstance is called for the first time.
  // This ensures that only one instance of ProjectState exists throughout the application.
  // The private constructor prevents instantiation from outside the class, enforcing the singleton pattern.
  // The getInstance method checks if an instance already exists; if it does, it returns that instance.
  // If no instance exists, it creates a new one and assigns it to the instance property.
  // This pattern is useful for managing global state in applications, ensuring that all parts
  // of the application share the same state without creating multiple instances.
  private static instance: ProjectState;

  // The constructor is private to prevent direct instantiation from outside the class.
  // This ensures that the class follows the singleton pattern, allowing only one instance to be created.
  // The super() call initializes the parent State class, which manages the listeners.
  private constructor() {
    super();
  }

  // getInstance method ensures that only one instance of ProjectState exists (singleton pattern).
  // If an instance already exists, it returns that instance; otherwise, it creates a new one.
  static getInstance() {
    if (this.instance) {
      return this.instance;
    }
    this.instance = new ProjectState();
    return this.instance;
  }

  // addProject method creates a new project and adds it to the projects array.
  // It generates a random id for the project and sets its status to Active.
  // After adding the project, it calls updateListeners to notify all registered listeners of the new project.
  addProject(title: string, description: string, numOfPeople: number) {
    const newProject = new Project(
      Math.random().toString(),
      title,
      description,
      numOfPeople,
      ProjectStatus.Active
    );
    this.projects.push(newProject);
    this.updateListeners();
  }

  // moveProject method changes the status of a project identified by its id.
  // It finds the project in the projects array and updates its status to the new status provided.
  // If the project is found and its status is different from the new status, it updates the status
  // and calls updateListeners to notify all registered listeners of the change.
  // This method is used to move projects between Active and Finished statuses.
  moveProject(projectId: string, newStatus: ProjectStatus) {
    const project = this.projects.find(prj => prj.id === projectId);
    if (project && project.status !== newStatus) {
      project.status = newStatus;
      this.updateListeners();
    }
  }

  // updateListeners method iterates through all registered listeners and calls each one with a copy of the current projects array.
  // This ensures that all parts of the application that are interested in project state changes are notified
  // whenever a project is added or moved.
  // It uses the slice method to create a shallow copy of the projects array, ensuring that
  // listeners receive the current state of projects without being affected by future changes.
  // This method is crucial for maintaining the reactive nature of the application, allowing UI components
  // to update automatically when the project state changes.
  private updateListeners() {
    for (const listenerFn of this.listeners) {
      listenerFn(this.projects.slice());
    }
  }
}

// Importing the ProjectState singleton instance to manage project state throughout the application.
// This instance is used to add projects, move them between statuses, and notify listeners of changes
const projectState = ProjectState.getInstance();

// Validation
// The Validatable interface defines the structure for input validation.
// It includes properties for value, required status, minimum and maximum lengths, and minimum and maximum values.
// This interface is used to ensure that inputs meet specific criteria before being processed.
interface Validatable {
  value: string | number;
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  min?: number;
  max?: number;
}

// The validate function checks if the provided input meets the criteria defined in the Validatable interface.
// It returns true if the input is valid according to the specified rules, such as being required,
// having a minimum or maximum length, or being within a specified range for numbers.
// This function is used to validate user inputs in forms, ensuring that only valid data is processed
function validate(validatableInput: Validatable) {
  let isValid = true;
  if (validatableInput.required) {
    isValid = isValid && validatableInput.value.toString().trim().length !== 0;
  }
  if (
    validatableInput.minLength != null &&
    typeof validatableInput.value === 'string'
  ) {
    isValid =
      isValid && validatableInput.value.length >= validatableInput.minLength;
  }
  if (
    validatableInput.maxLength != null &&
    typeof validatableInput.value === 'string'
  ) {
    isValid =
      isValid && validatableInput.value.length <= validatableInput.maxLength;
  }
  if (
    validatableInput.min != null &&
    typeof validatableInput.value === 'number'
  ) {
    isValid = isValid && validatableInput.value >= validatableInput.min;
  }
  if (
    validatableInput.max != null &&
    typeof validatableInput.value === 'number'
  ) {
    isValid = isValid && validatableInput.value <= validatableInput.max;
  }
  return isValid;
}

// Autobind Decorator
// This decorator binds the method to the class instance, ensuring 'this' refers to the class
// instance when the method is called, even if it's passed as a callback.
// This is useful for event handlers in classes.
// The decorator is defined as a function that takes three parameters:
// - _: any: The target object (not used here).
// - _2: string: The name of the method (not used here).
// - descriptor: PropertyDescriptor: The property descriptor of the method being decorated.
// The decorator returns a new property descriptor with a getter that binds the original method to the class instance.
// This ensures that when the method is called, 'this' refers to the class instance,
function autobind(_: any, _2: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  const adjDescriptor: PropertyDescriptor = {
    configurable: true,
    get() {
      const boundFn = originalMethod.bind(this);
      return boundFn;
    }
  };
  return adjDescriptor;
}

// Component Base Class
// This abstract class serves as a base for all components in the application.
// It provides a common structure for components, including a template element,
// a host element where the component will be rendered, and an element that represents the component itself.
// The constructor takes parameters for the template ID, host element ID, whether to insert at the start,
// and an optional new element ID.
// The attach method is responsible for inserting the component into the host element.
// The configure and renderContent methods are abstract, meaning that subclasses must implement them.
// This allows for flexibility in how different components are configured and rendered.
abstract class Component<T extends HTMLElement, U extends HTMLElement> {
  templateElement: HTMLTemplateElement;
  hostElement: T;
  element: U;


  constructor(
    templateId: string,
    hostElementId: string,
    insertAtStart: boolean,
    newElementId?: string
  ) {
    this.templateElement = document.getElementById(
      templateId
    )! as HTMLTemplateElement;
    this.hostElement = document.getElementById(hostElementId)! as T;

    const importedNode = document.importNode(
      this.templateElement.content,
      true
    );
    this.element = importedNode.firstElementChild as U;
    if (newElementId) {
      this.element.id = newElementId;
    }

    this.attach(insertAtStart);
  }

  private attach(insertAtBeginning: boolean) {
    this.hostElement.insertAdjacentElement(
      insertAtBeginning ? 'afterbegin' : 'beforeend',
      this.element
    );
  }

  abstract configure(): void;
  abstract renderContent(): void;
}

// ProjectItem Class
// This class represents a single project item in the project list.
// It extends the Component class and implements the Draggable interface,
// allowing it to be dragged and dropped.
// The ProjectItem class is responsible for rendering the project details,
// handling drag events, and displaying the number of people assigned to the project.
// It uses the autobind decorator to ensure that the drag event handlers are bound to the class instance,
// allowing them to access the project data correctly when called as event handlers.
class ProjectItem extends Component<HTMLUListElement, HTMLLIElement>
  implements Draggable {
  private project: Project;

  get persons() {
    if (this.project.people === 1) {
      return '1 person';
    } else {
      return `${this.project.people} persons`;
    }
  }

  constructor(hostId: string, project: Project) {
    super('single-project', hostId, false, project.id);
    this.project = project;

    this.configure();
    this.renderContent();
  }

  @autobind
  dragStartHandler(event: DragEvent) {
    event.dataTransfer!.setData('text/plain', this.project.id);
    event.dataTransfer!.effectAllowed = 'move';
  }

  dragEndHandler(_: DragEvent) {
    console.log('DragEnd');
  }

  configure() {
    this.element.addEventListener('dragstart', this.dragStartHandler);
    this.element.addEventListener('dragend', this.dragEndHandler);
  }

  renderContent() {
    this.element.querySelector('h2')!.textContent = this.project.title;
    this.element.querySelector('h3')!.textContent = this.persons + ' assigned';
    this.element.querySelector('p')!.textContent = this.project.description;
  }
}

// ProjectList Class
// This class represents a list of projects, either active or finished.
// It extends the Component class and implements the DragTarget interface,
// allowing it to accept dropped project items.
// The ProjectList class is responsible for rendering the list of projects,
// handling drag events, and updating the list when projects are added or moved.
// It uses the autobind decorator to ensure that the drag event handlers are bound to the class instance,
// allowing them to access the project state correctly when called as event handlers.
class ProjectList extends Component<HTMLDivElement, HTMLElement>
  implements DragTarget {
  assignedProjects: Project[];

  constructor(private type: 'active' | 'finished') {
    super('project-list', 'app', false, `${type}-projects`);
    this.assignedProjects = [];

    this.configure();
    this.renderContent();
  }

  @autobind
  dragOverHandler(event: DragEvent) {
    if (event.dataTransfer && event.dataTransfer.types[0] === 'text/plain') {
      event.preventDefault();
      const listEl = this.element.querySelector('ul')!;
      listEl.classList.add('droppable');
    }
  }

  @autobind
  dropHandler(event: DragEvent) {
    const prjId = event.dataTransfer!.getData('text/plain');
    projectState.moveProject(
      prjId,
      this.type === 'active' ? ProjectStatus.Active : ProjectStatus.Finished
    );
  }

  @autobind
  dragLeaveHandler(_: DragEvent) {
    const listEl = this.element.querySelector('ul')!;
    listEl.classList.remove('droppable');
  }

  configure() {
    this.element.addEventListener('dragover', this.dragOverHandler);
    this.element.addEventListener('dragleave', this.dragLeaveHandler);
    this.element.addEventListener('drop', this.dropHandler);

    projectState.addListener((projects: Project[]) => {
      const relevantProjects = projects.filter(prj => {
        if (this.type === 'active') {
          return prj.status === ProjectStatus.Active;
        }
        return prj.status === ProjectStatus.Finished;
      });
      this.assignedProjects = relevantProjects;
      this.renderProjects();
    });
  }

  renderContent() {
    const listId = `${this.type}-projects-list`;
    this.element.querySelector('ul')!.id = listId;
    this.element.querySelector('h2')!.textContent =
      this.type.toUpperCase() + ' PROJECTS';
  }

  private renderProjects() {
    const listEl = document.getElementById(
      `${this.type}-projects-list`
    )! as HTMLUListElement;
    listEl.innerHTML = '';
    for (const prjItem of this.assignedProjects) {
      new ProjectItem(this.element.querySelector('ul')!.id, prjItem);
    }
  }
}

// ProjectInput Class
// This class represents the input form for creating new projects.
// It extends the Component class and is responsible for gathering user input,
// validating it, and adding new projects to the project state.
// The ProjectInput class uses the autobind decorator to ensure that the submit handler is bound to the "this" class instance (ProjectInput),
// allowing it to access the input values correctly when the form is submitted.
// It also provides methods to gather user input, validate it, and clear the input fields after submission.
// The constructor initializes the input elements and sets up the event listener for form submission.
// The gatherUserInput method collects the input values, validates them using the validate function,
class ProjectInput extends Component<HTMLDivElement, HTMLFormElement> {
  titleInputElement: HTMLInputElement;
  descriptionInputElement: HTMLInputElement;
  peopleInputElement: HTMLInputElement;

  constructor() {
    super('project-input', 'app', true, 'user-input');
    this.titleInputElement = this.element.querySelector(
      '#title'
    ) as HTMLInputElement;
    this.descriptionInputElement = this.element.querySelector(
      '#description'
    ) as HTMLInputElement;
    this.peopleInputElement = this.element.querySelector(
      '#people'
    ) as HTMLInputElement;
    this.configure();
  }

  configure() {
    this.element.addEventListener('submit', this.submitHandler);
  }

  renderContent() { }

  // This method gathers user input from the form fields, validates it,
  // and returns the input values as a tuple if valid, or shows an alert if invalid
  // It checks if the title and description are not empty, the description has a minimum length
  // of 5 characters, and the number of people is between 1 and 5
  // If any validation fails, it alerts the user and returns void.
  // If all validations pass, it returns a tuple containing the title, description, and number of people.
  // This method is called when the form is submitted to gather the necessary data for creating a new project.
  // It uses the validate function to check the validity of each input field based on the rules
  // defined in the Validatable interface.
  private gatherUserInput(): [string, string, number] | void {
    const enteredTitle = this.titleInputElement.value;
    const enteredDescription = this.descriptionInputElement.value;
    const enteredPeople = this.peopleInputElement.value;

    const titleValidatable: Validatable = {
      value: enteredTitle,
      required: true
    };
    const descriptionValidatable: Validatable = {
      value: enteredDescription,
      required: true,
      minLength: 5
    };
    const peopleValidatable: Validatable = {
      value: +enteredPeople,
      required: true,
      min: 1,
      max: 5
    };

    if (
      !validate(titleValidatable) ||
      !validate(descriptionValidatable) ||
      !validate(peopleValidatable)
    ) {
      alert('Invalid input, please try again!');
      return;
    } else {
      return [enteredTitle, enteredDescription, +enteredPeople];
    }
  }

  private clearInputs() {
    this.titleInputElement.value = '';
    this.descriptionInputElement.value = '';
    this.peopleInputElement.value = '';
  }

  // This method handles the form submission event.
  // It prevents the default form submission behavior, gathers user input using gatherUserInput,
  // validates the input, and if valid, adds a new project to the project state.
  // If the input is valid, it calls the addProject method on the projectState instance
  // to add the new project, and then clears the input fields.
  // The autobind decorator ensures that the method is bound to the class instance,
  // allowing it to access the class properties and methods correctly when called as an event handler.
  @autobind
  private submitHandler(event: Event) {
    event.preventDefault();
    const userInput = this.gatherUserInput();
    if (Array.isArray(userInput)) {
      const [title, desc, people] = userInput;
      projectState.addProject(title, desc, people);
      this.clearInputs();
    }
  }
}

const prjInput = new ProjectInput();
const activePrjList = new ProjectList('active');
const finishedPrjList = new ProjectList('finished');
